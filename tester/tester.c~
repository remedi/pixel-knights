/*
Test 1 - Sending messages and checking responses
Test 2 - New user spamming test (Connectin and disconnecting multiple times)
Test 3 - User flood test (connecting as muliple clients)
Test 4 - Malunctional client test
Test 5 - Spamming chat with one user test
Test 6 - Spamming chat with multiple user test
Test 7 - Hybrid test with week load level
Test 8 - Hybrid test with average load level
Test 9 - Hybrid test with high load level
Test 10 - Hybrid test with extreme load level
Test 11 - Hybrid test with aaARrrRRGRHHGHGHGHHHGHG
*/

#include <errno.h>
#include <termios.h>
#include <fcntl.h>
#include <pthread.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>

#include <sys/types.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <sys/stat.h>
#include <sys/un.h>

#include "../maps/maps.h"
#include "../address.h"
#include "../client/client.h"
#include "../client/update.h"

#define BUFLEN 1000
#define MSGLEN 40
#define G_OFFSET_C 1
#define G_OFFSET_P 4

#include <time.h>


//Parse list from from given buffer, that contains serverlist. 
//Present that list to user and ask which server they want to connect.
//Copy server choosed by user to the start of argument buffer
int serverListParser(char *buf) {

    // Server count is an ASCII number
    int server_count = buf[1] - '0';
    int i = 0, user_input = -1;
    char **server_array = malloc(sizeof(char*) * server_count);

    // Parse the server list
    server_array[i] = strtok(buf+3, "\200");
    for (i = 1; i < server_count; i++) {
        server_array[i] = strtok(NULL, "\200");
    }
    printf("\nServer list from MM server:\n");
    for (i = 0; i < server_count; i++) {
        printf("%d: %s\n", i, server_array[i]);
    }

    // Force the user to choose a valid character
    while (user_input < 0 || user_input >= server_count) {
        printf("\nChoose a valid server (0 - %d):\n>>", server_count-1);
        user_input = getchar() - '0';
    }

    strncpy(buf, server_array[user_input], strlen(server_array[user_input]));

    free(server_array);
    return 0;
}



//Return 1 for IPv4 and 0 for all the others (We expect IPv6 then)
int isIpv4(char *buf) {
    int len = strlen(buf);
    int dot_count = 0, colon_count = 0, i;
    for(i = 0; i < len; i++) {
	if(buf[i] == '.')
	    dot_count++;
	if(buf[i] == ':')
	    colon_count++;
    }
    //Simple sanity check:
    if(dot_count == 0 && colon_count == 0)
	return -1;

    if(dot_count > colon_count)
	return 1;
    else
	return 0;
}

//Parse ip and port from character strings to a struct sockaddr_in6.
struct sockaddr_in6 ipv6_parser(char *ip, char *port) {
  struct sockaddr_in6 temp;
  if(inet_pton(AF_INET6, ip, &temp.sin6_addr) < 1) {
    perror("ipv6_parser, inet_pton");
    exit(-1);
  }
  temp.sin6_port = ntohs(strtol(port, NULL, 10));
  temp.sin6_family = AF_INET6;
  return temp;
}

//Parse ip and port from character strings to a struct sockaddr_in.
struct sockaddr_in ipv4_parser(char *ip, char *port) {
    struct sockaddr_in temp; 
    memset(&temp, 0, sizeof(struct sockaddr_in));
    if(inet_pton(AF_INET, ip, &temp.sin_addr) < 1) {
        perror("ipv4_parser, inet_pton");
    }
    temp.sin_port = ntohs(strtol(port, NULL, 10));
    temp.sin_family = AF_INET;
    return temp;
}


//Process character read from terminal. Return a character string that is send to the server afterwads.
char *processCommand(char id, unsigned char input, char *buf) {
    Action a; 
    memset(buf, '\0', BUFLEN);
    switch(input) {
	case 'w':
	    a = UP;
	    break;
	case 's':
	    a = DOWN;
	    break;
	case 'a':
	    a = LEFT;
	    break;
	case 'd':
	    a = RIGHT;
	    break;
	case 'i':
	    a = SHOOT_UP;
	    break;
	case 'k':
	    a = SHOOT_DOWN;
	    break;
	case 'j':
	    a = SHOOT_LEFT;
	    break;
	case 'l':
	    a = SHOOT_RIGHT;
	    break;
	default:
	    return NULL;
    }
    sprintf(buf, "A%c", id);
    memcpy(buf+2, &a, 1);
    return buf;
}

void SendPackagesAndCheckResponses(char *IP, char *Port, int IsExplanationNeeded)
{
	int generalError = 0;	
	char input_char = 1;
	struct sockaddr_in sock_addr_in;
	struct sockaddr_in6 sock_addr_in6;
	struct sockaddr *addr_ptr;
	char *buffer = malloc(BUFLEN);
	char *chat_buffer = malloc(BUFLEN);
	pthread_t thread;
	ssize_t bytes;
	char my_id, map_nr = 1, *ip, *port;
	char my_name[10];

	struct termios save_term, conf_term;
	int sock = 0, IP4 = 1, domain, exit_msg_needed = 0;
	socklen_t sock_len;
	struct sigaction sig_hand;

	printf("Running Test 1 - Sending all packages and checking received responses...  ");	
	
	//Connecting
	int IsIPv4 = isIpv4(IP);
	if(IsIPv4==1) {
	    sock_addr_in = ipv4_parser(IP, Port);
	    sock_len = sizeof(sock_addr_in);
	    addr_ptr = (struct sockaddr *) &sock_addr_in;
	    domain = AF_INET;
	}
	else {
	    sock_addr_in6 = ipv6_parser(IP, Port);
	    sock_len = sizeof(sock_addr_in6);
	    addr_ptr = (struct sockaddr *) &sock_addr_in6;
	    domain = AF_INET6;
	}

	if(IsExplanationNeeded==1) { 
		printf("\n--1Connecting with IPv%d...",IsIPv4==1?4:6); 
	}
		printf("\n--2Connecting with IPv%d...",IsIPv4==1?4:6); 
	if ((sock = socket(domain, SOCK_STREAM, 0)) == 0) {
		perror("--socket, creating");
		generalError = 1;		
	}
		printf("\n--3Connecting with IPv%d...",IsIPv4==1?4:6); 
	//Readin the socket and waiting for taken from update.h 
		printf("\n--4Connecting with IPv%d.%d..",IsIPv4==1?4:6,sock); 
	// Send hello message to server

my_name[10]="test\0\0\0\0\0\0";	

		printf("\n--5Connecting with IPv%d.%d..",IsIPv4==1?4:6,sock); 
	    printf("Sent: %s",buffer);
	    //printf("main: Sending 'hello' message to the server: %s\n", buffer);
	    if(write(sock, buffer, strlen(buffer) + 1) < 1) {
		perror("--main, write");
		    generalError = 1;
		    goto end;
	    }
		printf("\n--6Connecting with IPv%d...",IsIPv4==1?4:6); 
	    memset(buffer, '\0', BUFLEN);
            sprintf(buffer, "H%s", my_name);
	    // Read message from socket. It starts with I if its map server, and L if its MM server
	    if(read(sock, buffer, BUFLEN) < 1) {
		perror("--main, read");
		    generalError = 1;
		    goto end;
	    }
		printf("\n--7Connecting with IPv%d...",IsIPv4==1?4:6); 
printf("%s\n",buffer);
	    if(buffer[0] == 'I') {
		//Receive ID message
		printf("--main: ID message: ID: %d Map nr: %d\n", buffer[1], buffer[2]);
		my_id = buffer[1];
		map_nr = buffer[2];
		//Since we're connected to a map server, we need to send 'Q<ID>' when we exit the game
		exit_msg_needed = 1;
		    generalError = 1;
		    goto end;
	    }
	    else if(buffer[0] == 'L') {
		if(buffer[1] == '0') {
		    printf("--main: Connected to MM server but serverlist is empty\n");
		    generalError = 1;
		    goto end;
		}
		if(serverListParser(buffer) != 0) {
		    printf("--Error with serverListParser\n");
		    generalError = 1;
		    goto end;
		}
		ip = strtok(buffer, " ");
		port = strtok(NULL, " ");
		IP4 = isIpv4(ip);
		if(IP4) {
		    sock_addr_in = ipv4_parser(ip, port);
		    sock_len = sizeof(sock_addr_in);
		    addr_ptr = (struct sockaddr *) &sock_addr_in;
		    domain = AF_INET;
		}
		else {
		    sock_addr_in6 = ipv6_parser(ip, port);
		    sock_len = sizeof(sock_addr_in6);
		    addr_ptr = (struct sockaddr *) &sock_addr_in6;
		    domain = AF_INET6;
		}
	    }
	    else {
		printf("--Unexpected message from server: %s\n", buffer);
		    generalError = 1;
		    goto end;
	    }

	end:
		printf("\n--5Connecting with IPv%d...",IsIPv4==1?4:6);
getchar(); 
	return;

}

int main(int argc, char *argv[]) {

	char *buffer = malloc(BUFLEN);
	int x,y,z;
	srand(time(NULL));
	
	if(argc<3){
		printf("Use it properly!\nUsage: tester <ip> <port> (optional for extra info)<1>\n");
		return 0;
	}

	if (argc == 4 && atoi(argv[3])==1) 
	{
		SendPackagesAndCheckResponses(argv[1],argv[2],1);
	}
	else
	{
 		SendPackagesAndCheckResponses(argv[1],argv[2],0);
	}

	//printf("%s", processCommand(3,'b',buffer));

	return 0;
}
